<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>180° Rule & Line-of-Action Validator</title>
  <style>
    :root{--bg:#0f1724;--panel:#0b1220;--muted:#9aa4b2;--accent:#60a5fa}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
    body{background:linear-gradient(180deg,#071126 0%, #06101a 100%);color:#e6eef6;display:flex;gap:18px;padding:18px}
    .app{display:flex;flex-direction:row;flex:1;gap:16px}
    .canvas-wrap{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:12px;flex:1;min-width:520px}
    .sidebar{width:340px;background:var(--panel);border-radius:12px;padding:12px;box-shadow:0 6px 18px rgba(2,6,23,0.6)}
    header{display:flex;align-items:center;gap:12px}
    h1{font-size:16px;margin:0}
    p{color:var(--muted);margin:6px 0 0 0;font-size:13px}
    svg{width:100%;height:640px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));}
    .controls{display:grid;gap:8px;margin-top:10px}
    button,select,input[type=range]{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit}
    .row{display:flex;gap:8px}
    .row > *{flex:1}
    .small{font-size:13px;color:var(--muted)}
    .legend{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
    .legend .item{display:flex;align-items:center;gap:8px}
    .dot{width:12px;height:12px;border-radius:50%;}
    .dot.cam-ok{background:#22c55e}
    .dot.cam-bad{background:#ef4444}
    .dot.subject{background:#f59e0b}
    .footer{margin-top:12px;color:var(--muted);font-size:13px}
    .list{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;max-height:220px;overflow:auto}
    .item-line{display:flex;align-items:center;justify-content:space-between;padding:6px;border-radius:6px}
    .item-line:hover{background:rgba(255,255,255,0.01)}
  </style>
</head>
<body>
  <div class="app">
    <div class="canvas-wrap">
      <header>
        <div>
          <h1>180° Rule Visualizer</h1>
          <p>Drag cameras (C) and subjects (S). Select two subjects to define the line of action. Cameras must remain on the same side of that line.</p>
        </div>
      </header>
      <svg id="stage" viewBox="0 0 1200 800"></svg>
    </div>

    <aside class="sidebar">
      <div class="controls">
        <div class="row">
          <button id="add-subject">+ Add Subject</button>
          <button id="add-camera">+ Add Camera</button>
        </div>

        <div class="row">
          <select id="primaryA"></select>
          <select id="primaryB"></select>
        </div>

        <div class="row">
          <button id="toggle-line">Toggle Line</button>
          <button id="flip-line">Flip Side</button>
        </div>

        <div class="list" id="entities-list"></div>

        <div class="legend">
          <div class="item"><div class="dot subject"></div><div class="small">Subject (S)</div></div>
          <div class="item"><div class="dot cam-ok"></div><div class="small">Camera — OK</div></div>
          <div class="item"><div class="dot cam-bad"></div><div class="small">Camera — Violates</div></div>
        </div>

        <div class="footer">Tip: For multi-subject blocking, pick the two primary characters for the line-of-action. Crossing that line breaks the 180° rule.</div>
      </div>
    </aside>
  </div>

<script>
(function(){
  const svg = document.getElementById('stage');
  const NS = 'http://www.w3.org/2000/svg';
  let nextId=1;
  const state={subjects:[],cameras:[],selectedA:null,selectedB:null,showLine:true,flipped:false,selectedEntity:null,view:{x:0,y:0,w:1200,h:800}};

  function createSvg(tag,attrs={}){
    const el = document.createElementNS(NS,tag);
    for(const k in attrs) el.setAttribute(k,attrs[k]);
    return el;
  }

  // Background grid
  const grid = createSvg('g',{id:'grid'});
  for(let x=0;x<1200;x+=60){const line=createSvg('line',{x1:x,y1:0,x2:x,y2:800,stroke:'rgba(255,255,255,0.02)'});grid.appendChild(line)}
  for(let y=0;y<800;y+=60){const line=createSvg('line',{x1:0,y1:y,x2:1200,y2:y,stroke:'rgba(255,255,255,0.02)'});grid.appendChild(line)}
  svg.appendChild(grid);

  const layer = createSvg('g',{id:'layer'});
  svg.appendChild(layer);

  const lineGroup = createSvg('g',{id:'lineGroup'});
  svg.appendChild(lineGroup);

  function rand(min,max){return Math.random()*(max-min)+min}

  function addSubject(x,y){ const id='S'+(nextId++); const s={id, name:id, x:x||rand(200,900), y:y||rand(150,600)}; state.subjects.push(s); render(); }
  function addCamera(x,y){ const c={id:'C'+(nextId++),x:x||rand(200,900),y:y||rand(150,600),rot:0}; state.cameras.push(c); render(); }

  // initial items
  addSubject(360,360); addSubject(760,360);
  addCamera(200,200); addCamera(1000,200); addCamera(1000,600);

  // UI wiring
  document.getElementById('add-subject').onclick=()=>addSubject();
  document.getElementById('add-camera').onclick=()=>addCamera();
  document.getElementById('toggle-line').onclick=()=>{state.showLine=!state.showLine;render();}
  document.getElementById('flip-line').onclick=()=>{state.flipped=!state.flipped;render();}

  function populateSelectors(){
    const aSel=document.getElementById('primaryA'); const bSel=document.getElementById('primaryB');
    aSel.innerHTML=''; bSel.innerHTML='';
    const all = [...state.subjects];
    all.forEach(s=>{
      const optA = document.createElement('option'); optA.value=s.id; optA.textContent=s.name || s.id; aSel.appendChild(optA);
      const optB = document.createElement('option'); optB.value=s.id; optB.textContent=s.name || s.id; bSel.appendChild(optB);
    });
    if(!state.selectedA && all[0]) state.selectedA = all[0].id;
    if(!state.selectedB && all[1]) state.selectedB = all[1].id;
    aSel.value = state.selectedA || (all[0] && all[0].id) || '';
    bSel.value = state.selectedB || (all[1] && all[1].id) || '';
    aSel.onchange = ()=>{state.selectedA = aSel.value; render();}
    bSel.onchange = ()=>{state.selectedB = bSel.value; render();}
  }

  function render(){
    // Keep SVG viewBox synced to current pan/zoom
    svg.setAttribute('viewBox', `${state.view.x} ${state.view.y} ${state.view.w} ${state.view.h}`);

    layer.innerHTML=''; lineGroup.innerHTML='';
    // draw subjects
    state.subjects.forEach(s=>{
      const g=createSvg('g'); g.setAttribute('data-id',s.id);
      const circle=createSvg('circle',{cx:s.x,cy:s.y,r:16,fill:'#f59e0b',stroke:'#111', 'stroke-width':2});
      const nameLabel=createSvg('text',{
        x:s.x,
        y:s.y-24,
        'font-size':12,
        fill:'#e6eef6',
        'text-anchor':'middle',
        'paint-order':'stroke',
        stroke:'rgba(0,0,0,0.65)',
        'stroke-width':4,
        'data-name-label':'1'
      });
      nameLabel.textContent = s.name || s.id;
      g.appendChild(circle);
      g.appendChild(nameLabel);
      layer.appendChild(g);
    });

    // draw cameras
    state.cameras.forEach(c=>{
      const g=createSvg('g'); g.setAttribute('data-id',c.id);
      const rect=createSvg('rect',{x:c.x-12,y:c.y-8,width:24,height:16,rx:4,ry:4,fill:'#8fb3ff',stroke:'#0b1726','stroke-width':2});
      rect.setAttribute('transform',`rotate(${c.rot||0} ${c.x} ${c.y})`);
      const lens=createSvg('circle',{cx:c.x+10,cy:c.y, r:4, fill:'#08233a'});
      lens.setAttribute('transform',`rotate(${c.rot||0} ${c.x} ${c.y})`);
      const label=createSvg('text',{x:c.x-20,y:c.y+28,'font-size':12,fill:'#9fb7d9'}); label.textContent=c.id;
      g.appendChild(rect); g.appendChild(lens); g.appendChild(label);
      layer.appendChild(g);
    });

    populateSelectors();

    // draw line-of-action
    const A = state.subjects.find(s=>s.id===state.selectedA);
    const B = state.subjects.find(s=>s.id===state.selectedB);
    if(A && B && state.showLine){
      const L = createSvg('line',{x1:A.x,y1:A.y,x2:B.x,y2:B.y,stroke:'#60a5fa','stroke-width':3,'stroke-dasharray':'8 6'});
      lineGroup.appendChild(L);

      // draw perpendicular arrow showing allowed side (optional)
      const mx=(A.x+B.x)/2, my=(A.y+B.y)/2;
      const dx = B.x-A.x, dy = B.y-A.y;
      // normal vector
      let nx = -dy, ny = dx;
      // normalize
      const len = Math.hypot(nx,ny)||1; nx/=len; ny/=len;
      if(state.flipped){ nx *= -1; ny *= -1; }
      // draw an arrow showing the selected side
      const arrowEndX = mx + nx*100, arrowEndY = my + ny*100;
      const sideLine=createSvg('line',{x1:mx,y1:my,x2:arrowEndX,y2:arrowEndY,stroke:'#10b981','stroke-width':2});
      lineGroup.appendChild(sideLine);
      // semicircle illustrating 180° arc on that side
      const arcPath = describeSemiCircle(mx,my, dx,dy, nx,ny,100);
      const arc=createSvg('path',{d:arcPath,fill:'rgba(16,185,129,0.06)',stroke:'rgba(16,185,129,0.16)'});
      lineGroup.appendChild(arc);

      // evaluate cameras side
      state.cameras.forEach(c=>{
        const side = Math.sign((c.x - A.x)*(B.y - A.y) - (c.y - A.y)*(B.x - A.x));
        const refSide = Math.sign(nx*(1) + ny*(0)); // using nx,ny is directional; we'll compute per camera vs normal
        // Better: compute dot of (camera - midpoint) with normal
        const dot = (c.x - mx)*nx + (c.y - my)*ny;
        const ok = dot > 0;
        // color cameras accordingly
        const camEl = layer.querySelector('[data-id="'+c.id+'"]');
        if(camEl){
          const rect = camEl.querySelector('rect');
          rect.setAttribute('fill', ok? '#22c55e' : '#ef4444');
        }
        // attach small badge showing distance & angle
        const existingBadge = layer.querySelector('[data-badge="'+c.id+'"]'); if(existingBadge) existingBadge.remove();
        const badge = createSvg('text',{x:c.x+18,y:c.y-18,'font-size':12,fill:'#cfeef9','data-badge':c.id});
        const ang = angleBetween(A,B,{x:c.x,y:c.y});
        badge.textContent = (ok? 'OK ':'✕ ') + Math.round(ang)+'°';
        layer.appendChild(badge);
      });
    } else {
      // if no line, color cameras neutral
      state.cameras.forEach(c=>{ const camEl=layer.querySelector('[data-id="'+c.id+'"]'); if(camEl){camEl.querySelector('rect').setAttribute('fill','#8fb3ff')}})
    }

    rebuildList();
    enableDrag();
  }

  function describeSemiCircle(cx,cy, dx,dy, nx,ny, r){
    // build arc path centered at cx,cy offset a bit along normal to avoid overlapping the line
    const startX = cx + nx*r - dy*0.02; // rotate a touch
    const startY = cy + ny*r + dx*0.02;
    const endX = cx - nx*r - dy*0.02;
    const endY = cy - ny*r + dx*0.02;
    return `M ${startX} ${startY} A ${r} ${r} 0 0 0 ${endX} ${endY} L ${cx} ${cy} Z`;
  }

  function angleBetween(A,B,P){
    // angle at midpoint between AB and AP to show roughly camera angle relative
    const mx=(A.x+B.x)/2, my=(A.y+B.y)/2;
    const v1x = A.x - B.x, v1y = A.y - B.y;
    const v2x = P.x - mx, v2y = P.y - my;
    const dot = v1x*v2x + v1y*v2y; const l1=Math.hypot(v1x,v1y)||1; const l2=Math.hypot(v2x,v2y)||1;
    const cos = Math.max(-1, Math.min(1, dot/(l1*l2)));
    return Math.acos(cos)*180/Math.PI;
  }

  function updateSubjectNameUI(subjectId){
    const subj = state.subjects.find(s=>s.id===subjectId);
    if(!subj) return;

    // Update on-stage label without re-rendering (prevents input focus loss)
    const g = layer.querySelector('[data-id="'+subjectId+'"]');
    if(g){
      const t = g.querySelector('text[data-name-label="1"]');
      if(t) t.textContent = subj.name || subj.id;
    }

    // Update dropdown option display text
    const aSel = document.getElementById('primaryA');
    const bSel = document.getElementById('primaryB');
    [aSel,bSel].forEach(sel=>{
      if(!sel) return;
      Array.from(sel.options).forEach(opt=>{
        if(opt.value===subjectId) opt.textContent = subj.name || subj.id;
      });
    });
  }

  function rebuildList(){
    const list=document.getElementById('entities-list'); list.innerHTML='';
    [...state.subjects,...state.cameras].forEach(e=>{
      const div=document.createElement('div'); div.className='item-line';
      const left=document.createElement('div');
      if(e.name!==undefined){
        const input=document.createElement('input');
        input.type='text';
        input.value=e.name;
        input.style.width='120px';
        input.oninput=()=>{
          e.name=input.value;
          updateSubjectNameUI(e.id);
        };
        left.appendChild(input);
      } else {
        left.textContent = e.id;
      }
      const right=document.createElement('div'); right.innerHTML = `<button data-jump="${e.id}">Jump</button> <button data-delete="${e.id}">Del</button>`;
      div.appendChild(left); div.appendChild(right); list.appendChild(div);
    });
    list.querySelectorAll('button[data-jump]').forEach(b=>{b.onclick=(ev)=>{ const id=ev.target.getAttribute('data-jump'); jumpTo(id);} });
    list.querySelectorAll('button[data-delete]').forEach(b=>{b.onclick=(ev)=>{ const id=ev.target.getAttribute('data-delete'); deleteEntity(id);} });
  }

  function jumpTo(id){
    const ent = [...state.subjects,...state.cameras].find(x=>x.id===id);
    if(!ent) return;

    // Pan (do not change zoom)
    state.view.x = ent.x - state.view.w/2;
    state.view.y = ent.y - state.view.h/2;
    render();
  }

  function deleteEntity(id){ state.subjects = state.subjects.filter(s=>s.id!==id); state.cameras = state.cameras.filter(c=>c.id!==id); if(state.selectedA===id) state.selectedA=null; if(state.selectedB===id) state.selectedB=null; render(); }

  // Simple drag implementation for SVG group elements
  function enableDrag(){
    let current=null, offset={x:0,y:0};
    layer.querySelectorAll('g').forEach(g=>{
      g.style.cursor='grab';
      g.onmousedown = (ev)=>{
        state.selectedEntity = g.getAttribute('data-id');
        ev.preventDefault(); current=g; g.style.cursor='grabbing';
        const id=g.getAttribute('data-id');
        const pt=getPointFromEvent(ev);
        const ent = state.subjects.find(s=>s.id===id) || state.cameras.find(c=>c.id===id);
        offset.x = pt.x - ent.x; offset.y = pt.y - ent.y;
        document.onmousemove = (e)=>{
          const p = getPointFromEvent(e);
          ent.x = p.x - offset.x; ent.y = p.y - offset.y;
          render();
        }
        document.onmouseup = ()=>{ document.onmousemove=null; document.onmouseup=null; current.style.cursor='grab'; current=null; }
      }
    });
  }

  // Deselect when clicking empty canvas (background)
  svg.addEventListener('mousedown',(ev)=>{
    // Only clear selection if clicking directly on the SVG background, not on shapes
    if(ev.target === svg){
      state.selectedEntity = null;
      render();
    }
  });

  // Click empty space to clear selection (returns mousewheel to zoom mode)
  svg.addEventListener('mousedown',(ev)=>{
    // If click isn't on an entity group, deselect
    const hit = ev.target && ev.target.closest ? ev.target.closest('g[data-id]') : null;
    if(!hit){
      if(state.selectedEntity!==null){
        state.selectedEntity = null;
        render();
      }
    }
  }, true);

  svg.addEventListener('wheel',(ev)=>{
    ev.preventDefault();

    // If a camera is selected, mouse wheel rotates its icon (label remains unrotated)
    const id = state.selectedEntity;
    const cam = state.cameras.find(c=>c.id===id);
    if(cam){
      cam.rot += ev.deltaY>0 ? 5 : -5;
      // normalize to keep values reasonable
      cam.rot = ((cam.rot % 360) + 360) % 360;
      render();
      return;
    }

    // Otherwise: zoom about the mouse cursor
    const rect = svg.getBoundingClientRect();
    const vb = state.view;

    // mouse position in viewBox (world) coords
    const nx = (ev.clientX - rect.left) / rect.width;
    const ny = (ev.clientY - rect.top) / rect.height;
    const mx = vb.x + nx * vb.w;
    const my = vb.y + ny * vb.h;

    const factor = ev.deltaY>0 ? 1.12 : 1/1.12;
    const newW = vb.w * factor;
    const newH = vb.h * factor;

    // clamp zoom
    const minW = 300, maxW = 3600;
    const clampedW = Math.max(minW, Math.min(maxW, newW));
    const aspect = vb.h / vb.w;
    const clampedH = clampedW * aspect;

    // keep mouse point stationary in screen space by re-centering the viewBox
    const kx = (mx - vb.x) / vb.w;
    const ky = (my - vb.y) / vb.h;

    state.view.w = clampedW;
    state.view.h = clampedH;
    state.view.x = mx - kx * clampedW;
    state.view.y = my - ky * clampedH;

    render();
  },{passive:false});

  function getPointFromEvent(ev){
    const rect = svg.getBoundingClientRect();
    const vb = state.view;
    const nx = (ev.clientX - rect.left) / rect.width;
    const ny = (ev.clientY - rect.top) / rect.height;
    const x = vb.x + nx * vb.w;
    const y = vb.y + ny * vb.h;
    return {x,y};
  }

  // Keyboard quick actions
  window.addEventListener('keydown', (e)=>{
    // Ignore shortcuts while typing in inputs or selects
    const t = e.target;
    if(t && (t.tagName==='INPUT' || t.tagName==='TEXTAREA' || t.tagName==='SELECT' || t.isContentEditable)){
      return;
    }
    // Ignore shortcuts while typing in inputs, textareas, selects, or contenteditable elements
    const ae = document.activeElement;
    if(ae && (ae.tagName === 'INPUT' || ae.tagName === 'TEXTAREA' || ae.tagName === 'SELECT' || ae.isContentEditable)){
      return; // let the keystroke go to the focused element
    }

    if(e.key==='Escape'){
      state.selectedEntity = null;
      render();
      return;
    }
    if(e.key==='Delete' || e.key==='Backspace'){ // delete last camera
      state.cameras.pop(); render();
    }
    if(e.key==='s'){ addSubject(); }
    if(e.key==='c'){ addCamera(); }
  });

  render();
})();
</script>
</body>
</html>
